name: Deploy Backend to Azure

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:  # Allow manual trigger
    inputs:
      environment:
        description: 'Environment to deploy (prod, dev, staging)'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - dev
          - staging

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4
    
    - name: üéØ Determine Environment
      id: env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENV="${{ github.event.inputs.environment }}"
        else
          ENV="prod"
        fi
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        echo "üìå Deploying to: $ENV"

    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: ÔøΩ Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: ÔøΩ Detect changed backend projects
      id: changes
      run: |
        echo "Determining changed backend projects..."
        # For manual triggers, build all by default
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "attendance_changed=true" >> $GITHUB_OUTPUT
          echo "auth_changed=true" >> $GITHUB_OUTPUT
          echo "entryexit_changed=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
          echo "attendance_changed=true" >> $GITHUB_OUTPUT
          echo "auth_changed=true" >> $GITHUB_OUTPUT
          echo "entryexit_changed=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        git fetch --no-tags --prune
        CHANGED=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} || true)
        echo "Files changed: $CHANGED"

        if echo "$CHANGED" | grep -qE '^backend/AttendanceAPI/'; then
          echo "attendance_changed=true" >> $GITHUB_OUTPUT
        else
          echo "attendance_changed=false" >> $GITHUB_OUTPUT
        fi

        if echo "$CHANGED" | grep -qE '^backend/AuthAPI/'; then
          echo "auth_changed=true" >> $GITHUB_OUTPUT
        else
          echo "auth_changed=false" >> $GITHUB_OUTPUT
        fi

        if echo "$CHANGED" | grep -qE '^backend/EntryExitAPI/'; then
          echo "entryexit_changed=true" >> $GITHUB_OUTPUT
        else
          echo "entryexit_changed=false" >> $GITHUB_OUTPUT
        fi

    - name: ÔøΩüì¶ Setup build output dir
      run: mkdir -p ${{ env.DOTNET_ROOT }}

    - name: üîÅ Build & Publish Backends
      env:
        ATT_CHANGED: ${{ steps.changes.outputs.attendance_changed }}
        AUTH_CHANGED: ${{ steps.changes.outputs.auth_changed }}
        ENTRY_CHANGED: ${{ steps.changes.outputs.entryexit_changed }}
      run: |
        set -e
        ENV="${{ steps.env.outputs.environment }}"
        RG="vermillion-${ENV}-rg"

        # Define backend projects and corresponding app ids (used in webapp naming)
        PROJECTS=("AttendanceAPI" "AuthAPI" "EntryExitAPI")
        APP_IDS=("attendance-api" "auth-api" "entryexit-api")

        for i in "${!PROJECTS[@]}"; do
          PROJ=${PROJECTS[$i]}
          APP_ID=${APP_IDS[$i]}
          PROJECT_PATH="backend/$PROJ"
          OUT_DIR="${{ env.DOTNET_ROOT }}/myapp-$APP_ID"

          # Determine whether this project changed (skip if not)
          CHANGED_FLAG=false
          if [ "$PROJ" = "AttendanceAPI" ]; then
            CHANGED_FLAG="$ATT_CHANGED"
          elif [ "$PROJ" = "AuthAPI" ]; then
            CHANGED_FLAG="$AUTH_CHANGED"
          elif [ "$PROJ" = "EntryExitAPI" ]; then
            CHANGED_FLAG="$ENTRY_CHANGED"
          fi

          if [ "$CHANGED_FLAG" != "true" ]; then
            echo "Skipping $PROJ because no changes detected."
            continue
          fi

          echo "\n=== Building $PROJ (path=$PROJECT_PATH) ==="
          dotnet restore "$PROJECT_PATH"
          dotnet build "$PROJECT_PATH" --configuration Release --no-restore
          dotnet publish "$PROJECT_PATH" -c Release -o "$OUT_DIR"

          # Create zip artifact
          ZIP_PATH="$PWD/${APP_ID}.zip"
          if ! command -v zip >/dev/null 2>&1; then
            echo "zip not found, installing..."
            sudo apt-get update -y
            sudo apt-get install -y zip
          fi
          (cd "$OUT_DIR" && zip -r "$ZIP_PATH" .)

          # Determine webapp name
          WEBAPP_NAME="vermillion-${APP_ID}-${ENV}"

          echo "Prepared artifact for $PROJ -> $ZIP_PATH; target webapp: $WEBAPP_NAME"

          # Deploy
          echo "Deploying $ZIP_PATH to $WEBAPP_NAME in resource group $RG"

          # Verify web app exists before deploying
          set +e
          az webapp show --name "$WEBAPP_NAME" --resource-group "$RG" >/dev/null 2>&1
          APP_EXISTS=$?
          set -e

          if [ $APP_EXISTS -ne 0 ]; then
            echo "\n‚ùó Target web app '$WEBAPP_NAME' not found in resource group $RG. Trying fallback names...\n"

            # Try fallback: legacy single webapp name (vermillion-api-<env>)
            FALLBACK_NAME="vermillion-api-${ENV}"
            set +e
            az webapp show --name "$FALLBACK_NAME" --resource-group "$RG" >/dev/null 2>&1
            FALLBACK_EXISTS=$?
            set -e

            if [ $FALLBACK_EXISTS -eq 0 ]; then
              echo "‚úÖ Fallback web app found: $FALLBACK_NAME ‚Äî deploying there instead."
              WEBAPP_NAME="$FALLBACK_NAME"
            else
              echo "Listing web apps in resource group $RG for debugging:"
              az webapp list --resource-group "$RG" --query "[].{name:name,kind:kind,location:location}" -o table || true
              echo "\nHint: Run the 'Setup Azure Infrastructure' workflow to provision the web apps, or create the web app(s) manually in the portal." 
              echo "Failing the deployment to avoid creating resources unexpectedly."
              exit 2
            fi
          fi

          az webapp deploy --resource-group "$RG" --name "$WEBAPP_NAME" --src-path "$ZIP_PATH"
        done

    - name: ‚úÖ Deployment Complete
      run: |
        echo "‚úÖ Backend deployed successfully!"
        echo "üéØ Environment: ${{ steps.env.outputs.environment }}"
        echo "Deployed web apps: attendance-api, auth-api, entryexit-api (names suffixed with environment)"
