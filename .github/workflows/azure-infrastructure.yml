name: Setup Azure Infrastructure

on:
  workflow_dispatch:  # Manual trigger only
    inputs:
      environment:
        description: 'Environment (prod, dev, staging)'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - dev
          - staging
      location:
        description: 'Primary Azure Region for SQL Server and App Services'
        required: true
        default: 'northeurope'
        type: choice
        options:
          - northeurope
          - westeurope
          - uksouth
          - francecentral
          - germanywestcentral
          - swedencentral
          - norwayeast

jobs:
  create-infrastructure:
    runs-on: ubuntu-latest
    
    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üîê Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: ÔøΩ Register Azure Resource Providers
      run: |
        echo "Registering required Azure resource providers..."
        
        # Register all required providers
        az provider register --namespace Microsoft.Sql --wait
        az provider register --namespace Microsoft.Web --wait
        az provider register --namespace Microsoft.Storage --wait
        az provider register --namespace Microsoft.Insights --wait
        
        # Verify registration status
        echo "‚úÖ Microsoft.Sql: $(az provider show --namespace Microsoft.Sql --query "registrationState" -o tsv)"
        echo "‚úÖ Microsoft.Web: $(az provider show --namespace Microsoft.Web --query "registrationState" -o tsv)"
        echo "‚úÖ Microsoft.Storage: $(az provider show --namespace Microsoft.Storage --query "registrationState" -o tsv)"
        echo "‚úÖ Microsoft.Insights: $(az provider show --namespace Microsoft.Insights --query "registrationState" -o tsv)"
        
        echo "‚úÖ All resource providers registered successfully"

    - name:  Create Resource Group
      run: |
        ENV="${{ github.event.inputs.environment }}"
        RESOURCE_GROUP="vermillion-${ENV}-rg"

        echo "Creating Resource Group: $RESOURCE_GROUP"
        az group create \
          --name $RESOURCE_GROUP \
          --location ${{ github.event.inputs.location }}

        echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV
        echo "‚úÖ Resource Group created: $RESOURCE_GROUP"

    - name: üíæ Create Azure SQL Server
      run: |
        ENV="${{ github.event.inputs.environment }}"
        SQL_SERVER_NAME="vermillion-sql-${ENV}"
        SQL_ADMIN_USER="sqladmin"
        SQL_ADMIN_PASSWORD="${{ secrets.SQL_ADMIN_PASSWORD_PROD }}"
        LOCATION="${{ github.event.inputs.location }}"

        echo "======================================"
        echo "SQL Server Setup: $SQL_SERVER_NAME"
        echo "======================================"

        # If server already exists in the target resource group, use it. Otherwise create a new server.
        if az sql server show --name $SQL_SERVER_NAME --resource-group ${{ env.RESOURCE_GROUP }} >/dev/null 2>&1; then
          echo "SQL Server already exists in target resource group: $SQL_SERVER_NAME"
          SQL_LOCATION=$(az sql server show --name $SQL_SERVER_NAME --resource-group ${{ env.RESOURCE_GROUP }} --query location -o tsv)
        else
          if [ -z "$SQL_ADMIN_PASSWORD" ]; then
            echo "‚ùå ERROR: SQL_ADMIN_PASSWORD_PROD secret is not set!"; exit 1
          fi

          echo "Creating new SQL Server $SQL_SERVER_NAME in $LOCATION"
          set +e
          CREATE_OUTPUT=$(az sql server create --name $SQL_SERVER_NAME --resource-group ${{ env.RESOURCE_GROUP }} --location $LOCATION --admin-user $SQL_ADMIN_USER --admin-password "$SQL_ADMIN_PASSWORD" 2>&1)
          CREATE_RESULT=$?
          set -e

          if [ $CREATE_RESULT -ne 0 ]; then
            echo "‚ö†Ô∏è Failed to create SQL Server in $LOCATION:"
            echo "$CREATE_OUTPUT"
            
            # Check if it's a region capacity issue
            if echo "$CREATE_OUTPUT" | grep -q "RegionDoesNotAllowProvisioning\|not accepting creation"; then
              echo ""
              echo "üîÑ Trying fallback regions..."
              
              # Define fallback regions (prefer regions close to primary)
              FALLBACK_REGIONS=("northeurope" "uksouth" "swedencentral" "francecentral" "germanywestcentral")
              
              SUCCESS=false
              for FALLBACK_LOC in "${FALLBACK_REGIONS[@]}"; do
                if [ "$FALLBACK_LOC" = "$LOCATION" ]; then
                  continue  # Skip the original failed location
                fi
                
                echo "Attempting to create SQL Server in fallback region: $FALLBACK_LOC"
                set +e
                CREATE_OUTPUT=$(az sql server create --name $SQL_SERVER_NAME --resource-group ${{ env.RESOURCE_GROUP }} --location $FALLBACK_LOC --admin-user $SQL_ADMIN_USER --admin-password "$SQL_ADMIN_PASSWORD" 2>&1)
                CREATE_RESULT=$?
                set -e
                
                if [ $CREATE_RESULT -eq 0 ]; then
                  SQL_LOCATION=$FALLBACK_LOC
                  echo "‚úÖ SQL Server created successfully in fallback region: $SQL_LOCATION"
                  SUCCESS=true
                  break
                else
                  echo "‚ùå Failed in $FALLBACK_LOC, trying next region..."
                fi
              done
              
              if [ "$SUCCESS" = false ]; then
                echo ""
                echo "‚ùå Failed to create SQL Server in all attempted regions"
                echo "Last error: $CREATE_OUTPUT"
                exit 1
              fi
            else
              echo "Non-capacity error occurred. Exiting."
              exit 1
            fi
          else
            SQL_LOCATION=$LOCATION
            echo "‚úÖ SQL Server created: $SQL_SERVER_NAME in $SQL_LOCATION"
          fi
        fi

        # export envs for later steps
        echo "SQL_SERVER_NAME=$SQL_SERVER_NAME" >> $GITHUB_ENV
        echo "SQL_LOCATION=$SQL_LOCATION" >> $GITHUB_ENV
        echo "SQL_ADMIN_USER=$SQL_ADMIN_USER" >> $GITHUB_ENV
        echo "ENVIRONMENT=$ENV" >> $GITHUB_ENV

        # Create three databases for the services (idempotent)
        if [ "$ENV" = "prod" ]; then
          DB1="AttendanceDB_Prod"
          DB2="AuthDB_Prod"
          DB3="EntryExitDB_Prod"
        else
          DB1="AttendanceDB_${ENV}"
          DB2="AuthDB_${ENV}"
          DB3="EntryExitDB_${ENV}"
        fi

        echo "Creating databases: $DB1, $DB2, $DB3"
        az sql db create --resource-group ${{ env.RESOURCE_GROUP }} --server $SQL_SERVER_NAME --name "$DB1" --service-objective Basic || true
        az sql db create --resource-group ${{ env.RESOURCE_GROUP }} --server $SQL_SERVER_NAME --name "$DB2" --service-objective Basic || true
        az sql db create --resource-group ${{ env.RESOURCE_GROUP }} --server $SQL_SERVER_NAME --name "$DB3" --service-objective Basic || true

        echo "‚úÖ Databases ensured"

    - name: üî• Configure SQL Server Firewall
      run: |
        # Allow Azure services (create or update)
        az sql server firewall-rule create \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --server ${{ env.SQL_SERVER_NAME }} \
          --name AllowAzureServices \
          --start-ip-address 0.0.0.0 \
          --end-ip-address 0.0.0.0 \
          2>/dev/null || az sql server firewall-rule update \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --server ${{ env.SQL_SERVER_NAME }} \
          --name AllowAzureServices \
          --start-ip-address 0.0.0.0 \
          --end-ip-address 0.0.0.0
        
        echo "‚úÖ Firewall rule configured"

    - name: üåê Create App Service Plan
      run: |
        ENV="${{ github.event.inputs.environment }}"
        APP_PLAN_NAME="vermillion-attendance-plan-${ENV}"
        
        # Check if App Service Plan already exists
        if az appservice plan show --name $APP_PLAN_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
          echo "‚úÖ App Service Plan already exists: $APP_PLAN_NAME"
        else
          echo "Creating App Service Plan: $APP_PLAN_NAME (B1 Linux plan - small, low-cost)")
          az appservice plan create \
            --name $APP_PLAN_NAME \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --location ${{ env.SQL_LOCATION }} \
            --sku B1 \
            --is-linux
          echo "‚úÖ App Service Plan created: $APP_PLAN_NAME (B1 Linux)"
        fi
        
        echo "APP_PLAN_NAME=$APP_PLAN_NAME" >> $GITHUB_ENV

    - name: üöÄ Create Web Apps (Backends)
      run: |
        ENV="${{ github.event.inputs.environment }}"
        # Define three backend web apps
        BACKENDS=("attendance-api" "auth-api" "entryexit-api")

        for APP in "${BACKENDS[@]}"; do
          WEBAPP_NAME="vermillion-${APP}-${ENV}"

          if az webapp show --name $WEBAPP_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "‚úÖ Web App already exists: $WEBAPP_NAME"
          else
            echo "Creating Web App: $WEBAPP_NAME"
            az webapp create \
              --name $WEBAPP_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --plan ${{ env.APP_PLAN_NAME }} \
              --runtime "DOTNETCORE:8.0"
            echo "‚úÖ Web App created: $WEBAPP_NAME"
          fi

          # export each webapp name to env and list
          key_name=$(echo "${APP^^}_WEBAPP_NAME" | tr '-' '_')
          echo "$key_name=$WEBAPP_NAME" >> $GITHUB_ENV
        done

    - name: üîó Configure Connection Strings for Backends
      run: |
        # Connection string used by all backend web apps
        CONNECTION_STRING="Server=tcp:${{ env.SQL_SERVER_NAME }}.database.windows.net,1433;Initial Catalog=AttendanceDB;User ID=sqladmin;Password=${{ secrets.SQL_ADMIN_PASSWORD_PROD }};Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"

        # Iterate known backend env vars set earlier
        for k in ATTENDANCE_API_WEBAPP_NAME AUTH_API_WEBAPP_NAME ENTRYEXIT_API_WEBAPP_NAME; do
          # Indirect expansion to read variable by name
          WEBAPP_NAME=${!k}
          # fallback: get from constructed name if not present
          if [ -z "$WEBAPP_NAME" ]; then
            case $k in
              ATTENDANCE_API_WEBAPP_NAME) WEBAPP_NAME="vermillion-attendance-api-${{ github.event.inputs.environment }}" ;;
              AUTH_API_WEBAPP_NAME) WEBAPP_NAME="vermillion-auth-api-${{ github.event.inputs.environment }}" ;;
              ENTRYEXIT_API_WEBAPP_NAME) WEBAPP_NAME="vermillion-entryexit-api-${{ github.event.inputs.environment }}" ;;
            esac
          fi

          echo "Configuring connection string for $WEBAPP_NAME"
          az webapp config connection-string set \
            --name "$WEBAPP_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --connection-string-type SQLAzure \
            --settings DefaultConnection="$CONNECTION_STRING"
        done

        echo "‚úÖ Connection strings configured for backends"

    - name: ‚öôÔ∏è Configure App Settings for Backends
      run: |
        # common app settings for each backend
        for name in ATTENDANCE_API_WEBAPP_NAME AUTH_API_WEBAPP_NAME ENTRYEXIT_API_WEBAPP_NAME; do
          WEBAPP_NAME=${!name}
          if [ -z "$WEBAPP_NAME" ]; then
            case $name in
              ATTENDANCE_API_WEBAPP_NAME) WEBAPP_NAME="vermillion-attendance-api-${{ github.event.inputs.environment }}" ;;
              AUTH_API_WEBAPP_NAME) WEBAPP_NAME="vermillion-auth-api-${{ github.event.inputs.environment }}" ;;
              ENTRYEXIT_API_WEBAPP_NAME) WEBAPP_NAME="vermillion-entryexit-api-${{ github.event.inputs.environment }}" ;;
            esac
          fi

          az webapp config appsettings set \
            --name "$WEBAPP_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --settings \
              ASPNETCORE_ENVIRONMENT="Production" \
              WEBSITE_RUN_FROM_PACKAGE="1"

          echo "Configured app settings for $WEBAPP_NAME"
        done

        echo "‚úÖ App settings configured for all backends"

    - name: üì± Create Static Web Apps (Frontends)
      run: |
        ENV="${{ github.event.inputs.environment }}"
        # two frontends: web and mobile
        FRONTS=("web" "mobile")

        STATIC_WEB_APP_LOCATION="westeurope"

        for F in "${FRONTS[@]}"; do
          STATIC_APP_NAME="vermillion-${F}-${ENV}"

          if az staticwebapp show --name $STATIC_APP_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "‚úÖ Static Web App already exists: $STATIC_APP_NAME"
          else
            echo "Creating Static Web App: $STATIC_APP_NAME"
            az staticwebapp create \
              --name $STATIC_APP_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location $STATIC_WEB_APP_LOCATION \
              --sku Free
            echo "‚úÖ Static Web App created: $STATIC_APP_NAME in $STATIC_WEB_APP_LOCATION"
          fi

          key_name=$(echo "${F^^}_STATIC_APP_NAME" | tr '-' '_')
          echo "$key_name=$STATIC_APP_NAME" >> $GITHUB_ENV
        done

    - name: üìù Get Deployment URLs
      run: |
        echo "=========================================="
        echo "‚úÖ INFRASTRUCTURE CREATED SUCCESSFULLY!"
        echo "=========================================="
        echo ""
        echo "üåç Environment: ${{ github.event.inputs.environment }}"
        echo "ÔøΩ Resource Group: ${{ env.RESOURCE_GROUP }}"

        # Print backend URLs
        for name in ATTENDANCE_API_WEBAPP_NAME AUTH_API_WEBAPP_NAME ENTRYEXIT_API_WEBAPP_NAME; do
          WEBAPP=${!name}
          if [ -z "$WEBAPP" ]; then
            # fallback deterministic name
            case $name in
              ATTENDANCE_API_WEBAPP_NAME) WEBAPP="vermillion-attendance-api-${{ github.event.inputs.environment }}" ;;
              AUTH_API_WEBAPP_NAME) WEBAPP="vermillion-auth-api-${{ github.event.inputs.environment }}" ;;
              ENTRYEXIT_API_WEBAPP_NAME) WEBAPP="vermillion-entryexit-api-${{ github.event.inputs.environment }}" ;;
            esac
          fi
          echo "üîß Backend ($name): https://$WEBAPP.azurewebsites.net"
        done

        # Print static web app URLs
        for name in WEB_STATIC_APP_NAME MOBILE_STATIC_APP_NAME; do
          SNAME=${!name}
          if [ -n "$SNAME" ]; then
            HOST=$(az staticwebapp show --name "$SNAME" --resource-group ${{ env.RESOURCE_GROUP }} --query defaultHostname -o tsv)
            echo "ÔøΩüì± Frontend ($name): https://$HOST"
          fi
        done

        echo "üíæ SQL Server: ${{ env.SQL_SERVER_NAME }}.database.windows.net"
        echo "üåç SQL Location: ${{ env.SQL_LOCATION }}"
        echo "üåç Primary Location: ${{ github.event.inputs.location }}"
        echo ""
        echo "=========================================="
        echo "üìã NEXT STEPS:"
        echo "=========================================="
        echo ""
        echo "1. Add these secrets to your GitHub repository:" 
        echo "   - Go to: Settings ‚Üí Secrets and variables ‚Üí Actions"
        echo ""
        echo "2. Add AZURE_WEBAPP_PUBLISH_PROFILE_PROD for each backend (example):"
        echo "   Run: az webapp deployment list-publishing-profiles --name <WEBAPP_NAME> --resource-group ${{ env.RESOURCE_GROUP }} --xml"
        echo ""
        echo "3. Add AZURE_STATIC_WEB_APPS_API_TOKEN_PROD for each static app (example):"
        echo "   Run: az staticwebapp secrets list --name <STATIC_APP_NAME> --resource-group ${{ env.RESOURCE_GROUP }} --query 'properties.apiKey' -o tsv"
        echo ""
        echo "4. Update frontend/src/environments/environment.prod.ts:"
        echo "   apiUrl: 'https://<BACKEND_WEBAPP>.azurewebsites.net/api'"
        echo ""
        echo "5. Run 'Deploy Backend to Azure' workflow"
        echo "6. Run 'Deploy Frontend to Azure' workflow"
        echo "=========================================="
        echo ""
        echo "üí∞ Monthly Cost: ~$18 USD (est)"
        echo "üåç Location: ${{ github.event.inputs.location }}"
        echo "=========================================="
